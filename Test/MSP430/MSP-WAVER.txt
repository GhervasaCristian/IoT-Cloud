#include <msp430.h>

volatile unsigned short int sine[] = {
                               2048,  2447,  2831,  3185,  3495,  3750,  3939,
                               4056,  4095,  4056,  3939,  3750,  3495,  3185,
                               2831,  2447,  2048,  1649,  1265,   911,   601,
                                346,   157,    40,     1,    40,   157,   346,
                                601,   911,  1265,  1649 };

volatile unsigned short int square[] = {
                                        0,     0,     0,     0,     0,     0,     0,
                                        0,  4095,  4095,  4095,  4095,  4095,  4095,
                                     4095,  4095,  4095,  4095,  4095,  4095,  4095,
                                     4095,  4095,  4095,     0,     0,     0,     0,
                                        0,     0,     0,     0 };

volatile unsigned int i, i_1, i_2;

void Software_Trim();                       // Software Trim to get the best DCOFTRIM value
#define MCLK_FREQ_MHZ 16                    // MCLK = 16MHz

int main(void)
{
    WDTCTL = WDTPW + WDTHOLD;                 // Stop watch dog timer

    // Configure two FRAM waitstate as required by the device datasheet for MCLK
    FRCTL0 = FRCTLPW | NWAITS_2;

    __bis_SR_register(SCG0);                  // Disable FLL
    CSCTL3 = SELREF__REFOCLK;                 // Set REFO as FLL reference source
    CSCTL1 = DCOFTRIMEN_1 | DCOFTRIM0 | DCOFTRIM1 | DCORSEL_5; // DCOFTRIM=3, DCO Range = 16MHz
    CSCTL2 = FLLD_0 + 488;                    // DCODIV = 16MHz
    __delay_cycles(3);
    __bic_SR_register(SCG0);                  // Enable FLL
    Software_Trim();                          // Software Trim to get the best DCOFTRIM value
    CSCTL4 = SELMS__DCOCLKDIV | SELA__REFOCLK;
    CSCTL5 |= DIVM_0 | DIVS_3;                // MCLK=16MHz, SMCLK=2MHz

    i = 0;
    i_1 = 0;          // initial phase square 1
    i_2 = 0;          // starting at 0 index

    // Configure P3.1 for SAC2 OA output
    P3SEL0 |= BIT1;
    P3SEL1 |= BIT1;

    PM5CTL0 &= ~LOCKLPM5;                     // Disable GPIO power-on default high-Z mode

    // Configure reference module
    PMMCTL0_H = PMMPW_H;                      // Unlock PMM registers
    PMMCTL2 = INTREFEN | REFVSEL_1;           // Enable 2V internal ref
    while (!(PMMCTL2 & REFGENRDY));           // Wait for ref to settle

    // Configure SAC2
    SAC2DAC = DACSREF_1 | DACLSEL_3 | DACIE;   // 2V ref, DAC triggered by TB2.2
    SAC2DAT = square[i_2];
    SAC2DAC |= DACEN;                         // Enable DAC

    SAC2OA = NMUXEN | PMUXEN | PSEL_1 | NSEL_1; // OA input settings
    SAC2OA |= OAPM_0;                          // High-speed mode
    SAC2PGA = MSEL_1;                          // Buffer mode
    SAC2OA |= SACEN | OAEN;                    // Enable SAC and OA

    // Configure TimerB2 to generate DAC triggers
    TB2CCR0 = 200 - 1;
    TB2CCTL2 = OUTMOD_4;                      // Toggle mode (reset/set also OK)
    TB2CCR2 = 100;                            // Match at middle
    TB2CTL = TBSSEL__SMCLK | MC_1 | TBCLR;    // SMCLK, Up mode, Clear

    __bis_SR_register(GIE);                   // Enable interrupts
    while (1);                                // Loop forever
}

// ISR for SAC2 DAC
#pragma vector=SAC0_SAC2_VECTOR
__interrupt void SAC2_ISR(void)
{
    switch (__even_in_range(SAC2IV, SACIV_4))
    {
        case SACIV_0: break;
        case SACIV_2: break;
        case SACIV_4:
            i_2++;
            if (i_2 >= sizeof(square)/sizeof(square[0]))
                i_2 = 0;
            SAC2DAT = square[i_2];
            break;
        default: break;
    }
}


void Software_Trim()
{
    unsigned int oldDcoTap = 0xffff;
    unsigned int newDcoTap = 0xffff;
    unsigned int newDcoDelta = 0xffff;
    unsigned int bestDcoDelta = 0xffff;
    unsigned int csCtl0Copy = 0;
    unsigned int csCtl1Copy = 0;
    unsigned int csCtl0Read = 0;
    unsigned int csCtl1Read = 0;
    unsigned int dcoFreqTrim = 3;
    unsigned char endLoop = 0;

    do
    {
        CSCTL0 = 0x100;                         // DCO Tap = 256
        do
        {
            CSCTL7 &= ~DCOFFG;                  // Clear DCO fault flag
        }while (CSCTL7 & DCOFFG);               // Test DCO fault flag

        __delay_cycles((unsigned int)3000 * MCLK_FREQ_MHZ);// Wait FLL lock status (FLLUNLOCK) to be stable
                                                           // Suggest to wait 24 cycles of divided FLL reference clock
        while((CSCTL7 & (FLLUNLOCK0 | FLLUNLOCK1)) && ((CSCTL7 & DCOFFG) == 0));

        csCtl0Read = CSCTL0;                   // Read CSCTL0
        csCtl1Read = CSCTL1;                   // Read CSCTL1

        oldDcoTap = newDcoTap;                 // Record DCOTAP value of last time
        newDcoTap = csCtl0Read & 0x01ff;       // Get DCOTAP value of this time
        dcoFreqTrim = (csCtl1Read & 0x0070)>>4;// Get DCOFTRIM value

        if(newDcoTap < 256)                    // DCOTAP < 256
        {
            newDcoDelta = 256 - newDcoTap;     // Delta value between DCPTAP and 256
            if((oldDcoTap != 0xffff) && (oldDcoTap >= 256)) // DCOTAP cross 256
                endLoop = 1;                   // Stop while loop
            else
            {
                dcoFreqTrim--;
                CSCTL1 = (csCtl1Read & (~DCOFTRIM)) | (dcoFreqTrim<<4);
            }
        }
        else                                   // DCOTAP >= 256
        {
            newDcoDelta = newDcoTap - 256;     // Delta value between DCPTAP and 256
            if(oldDcoTap < 256)                // DCOTAP cross 256
                endLoop = 1;                   // Stop while loop
            else
            {
                dcoFreqTrim++;
                CSCTL1 = (csCtl1Read & (~DCOFTRIM)) | (dcoFreqTrim<<4);
            }
        }

        if(newDcoDelta < bestDcoDelta)         // Record DCOTAP closest to 256
        {
            csCtl0Copy = csCtl0Read;
            csCtl1Copy = csCtl1Read;
            bestDcoDelta = newDcoDelta;
        }

    }while(endLoop == 0);                      // Poll until endLoop == 1

    CSCTL0 = csCtl0Copy;                       // Reload locked DCOTAP
    CSCTL1 = csCtl1Copy;                       // Reload locked DCOFTRIM
    while(CSCTL7 & (FLLUNLOCK0 | FLLUNLOCK1)); // Poll until FLL is locked
}

